<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATChess - Decentralized Chess</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #333;
            background: #fff;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .square:hover {
            opacity: 0.9;
        }
        .square.light {
            background-color: #f0d9b5;
        }
        .square.dark {
            background-color: #b58863;
        }
        .square.selected {
            background-color: #ffeb3b !important;
            box-shadow: inset 0 0 0 3px #ff9800, 0 0 0 2px #ff6f00;
            transform: scale(1.05);
        }
        .square.highlight {
            background-color: #7fc97f;
        }
        .square.possible-move {
            background-color: rgba(124, 179, 66, 0.3) !important;
        }
        .square.possible-move:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: rgba(124, 179, 66, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 0 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        .game-info {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .form-group {
            margin: 10px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.info {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ATChess</h1>
        <p style="text-align: center;">Decentralized Chess on the AT Protocol</p>
        
        <div class="game-info">
            <h3>Game Status</h3>
            <div id="status" class="status info">Ready to play</div>
            <div>
                <strong>Current Player:</strong> <span id="currentPlayer">White</span>
            </div>
            <div>
                <strong>FEN:</strong> <span id="fenDisplay">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</span>
            </div>
        </div>
        
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="controls">
            <button id="newGameBtn">New Game</button>
            <button id="resetBtn">Reset Board</button>
            <button id="shareGameBtn" style="display: none;">Share Game</button>
        </div>
        
        <div class="game-info">
            <h3>Create New Game</h3>
            <div style="background: #e6f3ff; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px;">
                <strong>Note:</strong> You are currently logged in as <strong>Player 1</strong> (player1.test).<br>
                To play against someone else, use <strong>Player 2</strong> as opponent.
            </div>
            <div class="form-group">
                <label for="opponentDID">Opponent DID:</label>
                <input type="text" id="opponentDID" placeholder="did:plc:example123...">
                <small style="color: #666; font-size: 12px;">
                    Test DIDs: 
                    <a href="#" onclick="document.getElementById('opponentDID').value='did:plc:styupz2ghvg7hrq4optipm7s'; return false;">Player 1</a> | 
                    <a href="#" onclick="document.getElementById('opponentDID').value='did:plc:yguha7jixn3rlblla2pzbmwl'; return false;">Player 2</a>
                </small>
            </div>
            <div class="form-group">
                <label for="colorChoice">Your Color:</label>
                <select id="colorChoice">
                    <option value="white">White</option>
                    <option value="black">Black</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <button id="createGameBtn">Create Game</button>
        </div>
    </div>

    <script>
        class ChessUI {
            constructor() {
                this.board = null;
                this.selectedSquare = null;
                this.currentFEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                this.currentPlayer = 'white';
                this.gameId = null;
                
                this.initializeBoard();
                this.setupEventListeners();
                this.updateBoardFromFEN();
                this.loadGameFromUrl();
            }
            
            initializeBoard() {
                const board = document.getElementById('chessboard');
                board.innerHTML = '';
                
                // Create squares (a8 to h1)
                for (let rank = 8; rank >= 1; rank--) {
                    for (let file = 0; file < 8; file++) {
                        const square = document.createElement('div');
                        const fileName = String.fromCharCode(97 + file); // a-h
                        const squareName = fileName + rank;
                        
                        square.className = 'square ' + ((rank + file) % 2 === 0 ? 'dark' : 'light');
                        square.dataset.square = squareName;
                        square.addEventListener('click', (e) => this.handleSquareClick(e));
                        
                        board.appendChild(square);
                    }
                }
            }
            
            handleSquareClick(e) {
                const square = e.target.dataset.square;
                const hasPiece = e.target.textContent.trim() !== '';
                
                if (this.selectedSquare === null) {
                    // Only select squares that have pieces
                    if (hasPiece) {
                        this.selectedSquare = square;
                        e.target.classList.add('selected');
                    }
                } else if (this.selectedSquare === square) {
                    // Deselect same square
                    this.clearSelection();
                } else {
                    // Make move or select new piece
                    if (hasPiece && this.isOwnPiece(e.target.textContent.trim())) {
                        // If clicking on own piece, select it instead
                        this.clearSelection();
                        this.selectedSquare = square;
                        e.target.classList.add('selected');
                    } else {
                        // Make move (to empty square or capture opponent piece)
                        this.makeMove(this.selectedSquare, square);
                        this.clearSelection();
                    }
                }
            }
            
            isOwnPiece(pieceSymbol) {
                if (!pieceSymbol) return false;
                
                // White pieces are uppercase symbols: ♔♕♖♗♘♙
                // Black pieces are lowercase symbols: ♚♛♜♝♞♟
                const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
                const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
                
                if (this.currentPlayer === 'white') {
                    return whitePieces.includes(pieceSymbol);
                } else {
                    return blackPieces.includes(pieceSymbol);
                }
            }
            
            clearSelection() {
                if (this.selectedSquare) {
                    const element = document.querySelector(`[data-square="${this.selectedSquare}"]`);
                    if (element) {
                        element.classList.remove('selected');
                    }
                    this.selectedSquare = null;
                }
                
                // Clear all possible move highlights
                document.querySelectorAll('.square.possible-move').forEach(square => {
                    square.classList.remove('possible-move');
                });
            }
            
            async makeMove(from, to) {
                try {
                    console.log('Making move:', { from, to, gameId: this.gameId, currentFEN: this.currentFEN });
                    
                    // If no game ID, create a game first (auto-create for local games)
                    if (!this.gameId) {
                        console.log('No game ID found, creating a new game automatically');
                        await this.createAutoGame();
                    }
                    
                    const response = await fetch(`http://localhost:8080/api/moves`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            from: from,
                            to: to,
                            fen: this.currentFEN,
                            game_id: this.gameId
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.text();
                        throw new Error(error);
                    }
                    
                    const result = await response.json();
                    console.log('Move result:', result);
                    
                    if (!result.fen) {
                        throw new Error('No FEN in response: ' + JSON.stringify(result));
                    }
                    
                    this.currentFEN = result.fen;
                    this.updateBoardFromFEN();
                    this.updateStatus(`Move: ${result.san || 'Unknown'}`);
                    
                    // Update current player
                    this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                    document.getElementById('currentPlayer').textContent = 
                        this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                    
                    // Update URL to persist game state after moves
                    if (this.gameId) {
                        const gameSlug = this.encodeGameId(this.gameId);
                        const newUrl = window.location.origin + window.location.pathname + '?game=' + gameSlug;
                        window.history.replaceState({gameId: this.gameId}, `ATChess - Game ${gameSlug}`, newUrl);
                        console.log('Updated URL to persist game state:', newUrl);
                    }
                    
                    if (result.checkmate) {
                        this.updateStatus('Checkmate!', 'error');
                    } else if (result.check) {
                        this.updateStatus('Check!', 'error');
                    } else if (result.draw) {
                        this.updateStatus('Draw!', 'error');
                    }
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            updateBoardFromFEN() {
                const pieces = this.parseFEN(this.currentFEN);
                const squares = document.querySelectorAll('.square');
                
                squares.forEach(square => {
                    const squareName = square.dataset.square;
                    const piece = pieces[squareName];
                    square.textContent = piece ? this.getPieceSymbol(piece) : '';
                });
                
                document.getElementById('fenDisplay').textContent = this.currentFEN;
            }
            
            parseFEN(fen) {
                if (!fen || typeof fen !== 'string') {
                    console.error('Invalid FEN provided to parseFEN:', fen);
                    return {};
                }
                
                const pieces = {};
                const fenParts = fen.split(' ');
                if (fenParts.length < 1) {
                    console.error('Invalid FEN format:', fen);
                    return {};
                }
                
                const [boardStr] = fenParts;
                const ranks = boardStr.split('/');
                
                if (ranks.length !== 8) {
                    console.error('Invalid FEN board format:', boardStr);
                    return {};
                }
                
                for (let rankIndex = 0; rankIndex < 8; rankIndex++) {
                    const rank = 8 - rankIndex;
                    let fileIndex = 0;
                    
                    for (const char of ranks[rankIndex]) {
                        if (char >= '1' && char <= '8') {
                            fileIndex += parseInt(char);
                        } else {
                            const file = String.fromCharCode(97 + fileIndex);
                            pieces[file + rank] = char;
                            fileIndex++;
                        }
                    }
                }
                
                return pieces;
            }
            
            getPieceSymbol(piece) {
                const symbols = {
                    'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                    'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
                };
                return symbols[piece] || piece;
            }
            
            updateStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetBoard());
                document.getElementById('createGameBtn').addEventListener('click', () => this.createGame());
                document.getElementById('shareGameBtn').addEventListener('click', () => this.shareGame());
            }
            
            newGame() {
                this.currentFEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                this.currentPlayer = 'white';
                this.gameId = null;
                this.updateBoardFromFEN();
                this.updateStatus('Ready to play');
                document.getElementById('currentPlayer').textContent = 'White';
            }
            
            resetBoard() {
                this.newGame();
            }
            
            async createGame() {
                const opponentDID = document.getElementById('opponentDID').value;
                const color = document.getElementById('colorChoice').value;
                
                if (!opponentDID) {
                    this.updateStatus('Please enter opponent DID', 'error');
                    return;
                }
                
                try {
                    const response = await fetch('http://localhost:8080/api/games', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            opponent_did: opponentDID,
                            color: color
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to create game');
                    }
                    
                    const game = await response.json();
                    this.gameId = game.id;
                    this.updateStatus(`Game created! ID: ${game.id}`);
                    
                    // Update URL to game permalink
                    const gameSlug = this.encodeGameId(game.id);
                    const newUrl = window.location.origin + window.location.pathname + '?game=' + gameSlug;
                    window.history.pushState({gameId: game.id}, `ATChess - Game ${gameSlug}`, newUrl);
                    
                    // Show share button
                    document.getElementById('shareGameBtn').style.display = 'inline-block';
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            async createAutoGame() {
                // Create a game automatically with a default opponent for local games
                const defaultOpponent = 'did:plc:yguha7jixn3rlblla2pzbmwl'; // Player 2 from the note
                
                try {
                    const response = await fetch('http://localhost:8080/api/games', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            opponent_did: defaultOpponent,
                            color: 'white'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to auto-create game');
                    }
                    
                    const game = await response.json();
                    this.gameId = game.id;
                    this.updateStatus(`Game auto-created and moves will be saved! ID: ${game.id}`);
                    
                    // Update URL to game permalink
                    const gameSlug = this.encodeGameId(game.id);
                    const newUrl = window.location.origin + window.location.pathname + '?game=' + gameSlug;
                    window.history.pushState({gameId: game.id}, `ATChess - Game ${gameSlug}`, newUrl);
                    
                    // Show share button
                    document.getElementById('shareGameBtn').style.display = 'inline-block';
                    
                } catch (error) {
                    this.updateStatus(`Error auto-creating game: ${error.message}`, 'error');
                    throw error; // Re-throw to prevent the move from being made
                }
            }
            
            encodeGameId(gameId) {
                // Convert AT Protocol URI to URL-safe slug
                return btoa(gameId).replace(/[+/]/g, c => ({'+': '-', '/': '_'})[c]);
            }
            
            decodeGameId(gameSlug) {
                // Convert URL-safe slug back to AT Protocol URI
                const base64 = gameSlug.replace(/[-_]/g, c => ({'-': '+', '_': '/'})[c]);
                const padded = base64 + '='.repeat((4 - base64.length % 4) % 4);
                return atob(padded);
            }
            
            async loadGameFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const gameSlug = urlParams.get('game');
                
                if (gameSlug) {
                    try {
                        const gameId = this.decodeGameId(gameSlug);
                        this.gameId = gameId;
                        
                        // Update page title
                        document.title = `ATChess - Game ${gameSlug}`;
                        
                        // Show share button
                        document.getElementById('shareGameBtn').style.display = 'inline-block';
                        
                        // Fetch game state from the API using base64 encoded game ID
                        const encodedGameId = this.encodeGameId(gameId);
                        const response = await fetch(`http://localhost:8080/api/games/${encodedGameId}`);
                        if (response.ok) {
                            const game = await response.json();
                            console.log('Loaded game from API:', game);
                            
                            // Update game state - fallback to initial position if no FEN
                            this.currentFEN = game.fen || 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                            this.updateBoardFromFEN();
                            
                            // Determine current player from FEN
                            const fenParts = this.currentFEN.split(' ');
                            this.currentPlayer = fenParts[1] === 'w' ? 'white' : 'black';
                            document.getElementById('currentPlayer').textContent = 
                                this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                            
                            this.updateStatus(`Loaded game: ${gameSlug}`);
                        } else {
                            this.updateStatus(`Game not found: ${gameSlug}`, 'error');
                        }
                        
                    } catch (error) {
                        this.updateStatus(`Error loading game from URL: ${error.message}`, 'error');
                    }
                }
            }
            
            shareGame() {
                if (this.gameId) {
                    const gameSlug = this.encodeGameId(this.gameId);
                    const gameUrl = window.location.origin + window.location.pathname + '?game=' + gameSlug;
                    
                    // Try to use the Clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(gameUrl).then(() => {
                            this.updateStatus('Game URL copied to clipboard!');
                        }).catch(() => {
                            this.fallbackCopyToClipboard(gameUrl);
                        });
                    } else {
                        this.fallbackCopyToClipboard(gameUrl);
                    }
                } else {
                    this.updateStatus('No game to share', 'error');
                }
            }
            
            fallbackCopyToClipboard(text) {
                // Fallback method for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    this.updateStatus('Game URL copied to clipboard!');
                } catch (err) {
                    this.updateStatus(`Share this URL: ${text}`, 'info');
                }
                document.body.removeChild(textArea);
            }
        }
        
        // Initialize the chess UI when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ChessUI();
        });
    </script>
</body>
</html>